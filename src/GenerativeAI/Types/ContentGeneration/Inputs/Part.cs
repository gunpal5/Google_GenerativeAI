using System.Text.Json.Serialization;

namespace GenerativeAI.Types;

/// <summary>
/// A datatype containing media that is part of a multi-part <see cref="Content"/> message.
/// A <see cref="Part"/> consists of data which has an associated datatype.<br/>
/// A <see cref="Part"/> must have a fixed IANA MIME type identifying the type and subtype of the media
/// if the <see cref="Part.InlineData"/> field is filled with raw bytes.
/// </summary>
/// <seealso href="https://ai.google.dev/api/caching#Part">See Official Documentation</seealso>
public class Part
{
    /// <summary>
    /// Inline text.
    /// </summary>
    [JsonPropertyName("text")]
    public string? Text { get; set; } 

    /// <summary>
    /// Inline media bytes.
    /// </summary>
    [JsonPropertyName("inlineData")]
    public Blob? InlineData { get; set; } 

    /// <summary>
    /// A predicted <see cref="FunctionCall"/> returned from the model that contains a string
    /// representing the <see cref="FunctionDeclaration.Name"/> with the arguments and their values.
    /// </summary>
    [JsonPropertyName("functionCall")]
    public FunctionCall? FunctionCall { get; set; } 

    /// <summary>
    /// The result output of a <see cref="FunctionCall"/> that contains a string representing the
    /// <see cref="FunctionDeclaration.Name"/> and a structured JSON object containing any output
    /// from the function is used as context to the model.
    /// </summary>
    [JsonPropertyName("functionResponse")]
    public FunctionResponse? FunctionResponse { get; set; } 

    /// <summary>
    /// URI based data.
    /// </summary>
    [JsonPropertyName("fileData")]
    public FileData? FileData { get; set; } 

    /// <summary>
    /// Code generated by the model that is meant to be executed.
    /// </summary>
    [JsonPropertyName("executableCode")]
    public ExecutableCode? ExecutableCode { get; set; } 

    /// <summary>
    /// Result of executing the <see cref="ExecutableCode">ExecutableCode</see>.
    /// </summary>
    [JsonPropertyName("codeExecutionResult")]
    public CodeExecutionResult? CodeExecutionResult { get; set; }
    
    /// <summary>
    /// Metadata for a given video.
    /// </summary>
    [JsonPropertyName("videoMetadata")]
    public VideoMetadataResult? VideoMetadata { get; set; }

    /// <summary>
    /// Represents a structured part of content that can include various types of data,
    /// such as plain text, inline data, function calls, or code execution details.
    /// </summary>
    public Part()
    {
        
    }

    /// <summary>
    /// Represents a component of a multi-part message in content processing. A Part includes media
    /// or data of various forms such as text, binary data, function invocation, or code execution details.
    /// Each Part is associated with a specific data type.
    /// </summary>
    public Part(string text)
    {
        this.Text = text;
    }
    
    /// <summary>
    /// Indicates if the part is thought from the model.
    /// </summary>
    [JsonPropertyName("thought")]
    public bool? Thought { get; set; }

    /// <summary>
    /// An opaque signature for the thought so it can be reused in subsequent requests.
    /// A base64-encoded string.
    /// </summary>
    [JsonPropertyName("thoughtSignature")]
    public string? ThoughtSignature { get; set; }
}

/// <summary>
/// Metadata describes the input video content.
/// Describes how the video in the Part should be used by the model.
/// </summary>
public class VideoMetadataResult
{
    /// <summary>
    /// Optional. The frame rate of the video sent to the model.
    /// If not specified, the default value will be 1.0. The fps range is (0.0, 24.0].
    /// </summary>
    [JsonPropertyName("fps")]
    public float? Fps { get; set; }

    /// <summary>
    /// Optional. The start offset of the video.
    /// </summary>
    [JsonPropertyName("startOffset")]
    public string? StartOffset { get; set; }

    /// <summary>
    /// Optional. The end offset of the video.
    /// </summary>
    [JsonPropertyName("endOffset")]
    public string? EndOffset { get; set; }
}
    
   